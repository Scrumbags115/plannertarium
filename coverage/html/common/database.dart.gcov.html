<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - lcov.info - common\database.dart</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">common\database.dart</a> - database.dart<span style="font-size: 80%;"> (source / <a href="database.dart.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">lcov.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">196</td>
            <td class="headerCovTableEntry">365</td>
            <td class="headerCovTableEntryLo">53.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">Wed Nov 29 00:23:40 2023</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntryHi">-</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : import 'dart:async';</a>
<a name="2"><span class="lineNum">       2 </span>            : </a>
<a name="3"><span class="lineNum">       3 </span>            : import 'package:cloud_firestore/cloud_firestore.dart';</a>
<a name="4"><span class="lineNum">       4 </span>            : import 'package:planner/common/time_management.dart';</a>
<a name="5"><span class="lineNum">       5 </span>            : import 'package:planner/models/event.dart';</a>
<a name="6"><span class="lineNum">       6 </span>            : import 'package:planner/models/task.dart';</a>
<a name="7"><span class="lineNum">       7 </span>            : import 'package:planner/models/tag.dart';</a>
<a name="8"><span class="lineNum">       8 </span>            : import 'package:planner/models/undertaking.dart';</a>
<a name="9"><span class="lineNum">       9 </span>            : </a>
<a name="10"><span class="lineNum">      10 </span>            : class DatabaseService {</a>
<a name="11"><span class="lineNum">      11 </span><span class="lineNoCov">          0 :   static final DatabaseService _singleton = DatabaseService._internal();</span></a>
<a name="12"><span class="lineNum">      12 </span>            :   late String userid;</a>
<a name="13"><span class="lineNum">      13 </span>            :   late FirebaseFirestore fs;</a>
<a name="14"><span class="lineNum">      14 </span>            : </a>
<a name="15"><span class="lineNum">      15 </span>            :   // TODO: Add caching layer here if time permits</a>
<a name="16"><span class="lineNum">      16 </span>            : </a>
<a name="17"><span class="lineNum">      17 </span>            :   // users collection reference</a>
<a name="18"><span class="lineNum">      18 </span><span class="lineNoCov">          0 :   late CollectionReference users =</span></a>
<a name="19"><span class="lineNum">      19 </span><span class="lineNoCov">          0 :       FirebaseFirestore.instance.collection('users');</span></a>
<a name="20"><span class="lineNum">      20 </span>            : </a>
<a name="21"><span class="lineNum">      21 </span><span class="lineNoCov">          0 :   factory DatabaseService({String? uid}) {</span></a>
<a name="22"><span class="lineNum">      22 </span><span class="lineNoCov">          0 :     return _singleton;</span></a>
<a name="23"><span class="lineNum">      23 </span>            :   }</a>
<a name="24"><span class="lineNum">      24 </span>            : </a>
<a name="25"><span class="lineNum">      25 </span><span class="lineNoCov">          0 :   DatabaseService._internal();</span></a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span>            :   /// constructor for testing, firestoreObject should be the replacement mocking firestore object</a>
<a name="28"><span class="lineNum">      28 </span><span class="lineCov">          3 :   DatabaseService.createTest({required String uid, required firestoreObject}) {</span></a>
<a name="29"><span class="lineNum">      29 </span><span class="lineCov">          3 :     userid = uid;</span></a>
<a name="30"><span class="lineNum">      30 </span><span class="lineCov">          6 :     users = firestoreObject.collection('users');</span></a>
<a name="31"><span class="lineNum">      31 </span><span class="lineCov">          3 :     fs = firestoreObject;</span></a>
<a name="32"><span class="lineNum">      32 </span>            :   }</a>
<a name="33"><span class="lineNum">      33 </span>            : </a>
<a name="34"><span class="lineNum">      34 </span><span class="lineNoCov">          0 :   get firestoreObject =&gt; fs;</span></a>
<a name="35"><span class="lineNum">      35 </span>            : </a>
<a name="36"><span class="lineNum">      36 </span>            :   /// Assign UID. This must be ran before any other database function is called else it will crash</a>
<a name="37"><span class="lineNum">      37 </span>            :   /// takes the string ID</a>
<a name="38"><span class="lineNum">      38 </span><span class="lineNoCov">          0 :   initUID(String uid) {</span></a>
<a name="39"><span class="lineNum">      39 </span><span class="lineNoCov">          0 :     userid = uid;</span></a>
<a name="40"><span class="lineNum">      40 </span>            :   }</a>
<a name="41"><span class="lineNum">      41 </span>            : </a>
<a name="42"><span class="lineNum">      42 </span>            : ////////////////////////////////////////////////////</a>
<a name="43"><span class="lineNum">      43 </span>            : </a>
<a name="44"><span class="lineNum">      44 </span><span class="lineCov">          1 :   Future&lt;Event&gt; getEvent(String eventID) async {</span></a>
<a name="45"><span class="lineNum">      45 </span>            :     try {</a>
<a name="46"><span class="lineNum">      46 </span>            :       DocumentSnapshot&lt;Map&lt;String, dynamic&gt;&gt; eventDocument =</a>
<a name="47"><span class="lineNum">      47 </span><span class="lineCov">          6 :           await users.doc(userid).collection('events').doc(eventID).get();</span></a>
<a name="48"><span class="lineNum">      48 </span><span class="lineCov">          2 :       if (eventDocument.exists &amp;&amp; eventDocument.data() != null) {</span></a>
<a name="49"><span class="lineNum">      49 </span><span class="lineCov">          2 :         return Event.fromMap(eventDocument.data() ?? {&quot;getEvent Error&quot;: 1},</span></a>
<a name="50"><span class="lineNum">      50 </span><span class="lineCov">          1 :             id: eventDocument.id);</span></a>
<a name="51"><span class="lineNum">      51 </span>            :       }</a>
<a name="52"><span class="lineNum">      52 </span>            :     } catch (e) {</a>
<a name="53"><span class="lineNum">      53 </span>            :       rethrow;</a>
<a name="54"><span class="lineNum">      54 </span>            :     }</a>
<a name="55"><span class="lineNum">      55 </span><span class="lineNoCov">          0 :     throw Exception(&quot;Event not found&quot;);</span></a>
<a name="56"><span class="lineNum">      56 </span>            :   }</a>
<a name="57"><span class="lineNum">      57 </span>            : </a>
<a name="58"><span class="lineNum">      58 </span><span class="lineNoCov">          0 :   Future&lt;List&lt;Event&gt;&gt; getAllEvents() async {</span></a>
<a name="59"><span class="lineNum">      59 </span><span class="lineNoCov">          0 :     List&lt;Event&gt; allEvents = [];</span></a>
<a name="60"><span class="lineNum">      60 </span><span class="lineNoCov">          0 :     final eventDocs = await users.doc(userid).collection(&quot;events&quot;).get();</span></a>
<a name="61"><span class="lineNum">      61 </span>            : </a>
<a name="62"><span class="lineNum">      62 </span><span class="lineNoCov">          0 :     for (var doc in eventDocs.docs) {</span></a>
<a name="63"><span class="lineNum">      63 </span><span class="lineNoCov">          0 :       allEvents.add(Event.fromMap(doc.data(), id: doc.id));</span></a>
<a name="64"><span class="lineNum">      64 </span>            :     }</a>
<a name="65"><span class="lineNum">      65 </span>            : </a>
<a name="66"><span class="lineNum">      66 </span>            :     return allEvents;</a>
<a name="67"><span class="lineNum">      67 </span>            :   }</a>
<a name="68"><span class="lineNum">      68 </span>            : </a>
<a name="69"><span class="lineNum">      69 </span>            :   /// Put a new event in database. Error if already exists</a>
<a name="70"><span class="lineNum">      70 </span><span class="lineCov">          1 :   Future&lt;void&gt; addEvent(Event event) async {</span></a>
<a name="71"><span class="lineNum">      71 </span><span class="lineCov">          7 :     var doc = await users.doc(userid).collection(&quot;events&quot;).doc(event.id).get();</span></a>
<a name="72"><span class="lineNum">      72 </span><span class="lineCov">          1 :     if (doc.exists) {</span></a>
<a name="73"><span class="lineNum">      73 </span><span class="lineNoCov">          0 :       throw Future.error(&quot;Event ID already exists!&quot;);</span></a>
<a name="74"><span class="lineNum">      74 </span>            :     }</a>
<a name="75"><span class="lineNum">      75 </span><span class="lineCov">          1 :     return await users</span></a>
<a name="76"><span class="lineNum">      76 </span><span class="lineCov">          2 :         .doc(userid)</span></a>
<a name="77"><span class="lineNum">      77 </span><span class="lineCov">          1 :         .collection(&quot;events&quot;)</span></a>
<a name="78"><span class="lineNum">      78 </span><span class="lineCov">          2 :         .doc(event.id)</span></a>
<a name="79"><span class="lineNum">      79 </span><span class="lineCov">          2 :         .set(event.toMap());</span></a>
<a name="80"><span class="lineNum">      80 </span>            :   }</a>
<a name="81"><span class="lineNum">      81 </span>            : </a>
<a name="82"><span class="lineNum">      82 </span>            :   /// set an event in database</a>
<a name="83"><span class="lineNum">      83 </span><span class="lineCov">          1 :   Future&lt;void&gt; setEvent(Event event) async {</span></a>
<a name="84"><span class="lineNum">      84 </span><span class="lineCov">          1 :     return await users</span></a>
<a name="85"><span class="lineNum">      85 </span><span class="lineCov">          2 :         .doc(userid)</span></a>
<a name="86"><span class="lineNum">      86 </span><span class="lineCov">          1 :         .collection('events')</span></a>
<a name="87"><span class="lineNum">      87 </span><span class="lineCov">          2 :         .doc(event.id)</span></a>
<a name="88"><span class="lineNum">      88 </span><span class="lineCov">          2 :         .set(event.toMap());</span></a>
<a name="89"><span class="lineNum">      89 </span>            :   }</a>
<a name="90"><span class="lineNum">      90 </span>            : </a>
<a name="91"><span class="lineNum">      91 </span>            :   /// Get all events within a date range as a Map</a>
<a name="92"><span class="lineNum">      92 </span>            :   /// Returns a map, with the eventID being the key and value being an Event class</a>
<a name="93"><span class="lineNum">      93 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;String, Event&gt;&gt; getEventsInDateRange(</span></a>
<a name="94"><span class="lineNum">      94 </span>            :       {required DateTime dateStart, required DateTime dateEnd}) async {</a>
<a name="95"><span class="lineNum">      95 </span><span class="lineNoCov">          0 :     final timestampStart = Timestamp.fromDate(dateStart);</span></a>
<a name="96"><span class="lineNum">      96 </span><span class="lineNoCov">          0 :     final timestampEnd = Timestamp.fromDate(dateEnd);</span></a>
<a name="97"><span class="lineNum">      97 </span>            :     // i can't do a composite search as it requires a composite index, which is not built automatically and has a limit in firestore</a>
<a name="98"><span class="lineNum">      98 </span>            :     // instead, get two query snapshots</a>
<a name="99"><span class="lineNum">      99 </span>            :     // one for catching time starts and one for catching time ends</a>
<a name="100"><span class="lineNum">     100 </span>            :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; eventsTimeStartInRange =</a>
<a name="101"><span class="lineNum">     101 </span><span class="lineNoCov">          0 :         await users</span></a>
<a name="102"><span class="lineNum">     102 </span><span class="lineNoCov">          0 :             .doc(userid)</span></a>
<a name="103"><span class="lineNum">     103 </span><span class="lineNoCov">          0 :             .collection(&quot;events&quot;)</span></a>
<a name="104"><span class="lineNum">     104 </span><span class="lineNoCov">          0 :             .where(&quot;time start&quot;,</span></a>
<a name="105"><span class="lineNum">     105 </span>            :                 isGreaterThanOrEqualTo: timestampStart,</a>
<a name="106"><span class="lineNum">     106 </span>            :                 isLessThanOrEqualTo: timestampEnd)</a>
<a name="107"><span class="lineNum">     107 </span><span class="lineNoCov">          0 :             .get();</span></a>
<a name="108"><span class="lineNum">     108 </span>            : </a>
<a name="109"><span class="lineNum">     109 </span><span class="lineNoCov">          0 :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; eventsTimeEndInRange = await users</span></a>
<a name="110"><span class="lineNum">     110 </span><span class="lineNoCov">          0 :         .doc(userid)</span></a>
<a name="111"><span class="lineNum">     111 </span><span class="lineNoCov">          0 :         .collection(&quot;events&quot;)</span></a>
<a name="112"><span class="lineNum">     112 </span><span class="lineNoCov">          0 :         .where(&quot;event time end&quot;,</span></a>
<a name="113"><span class="lineNum">     113 </span>            :             isGreaterThanOrEqualTo: timestampStart,</a>
<a name="114"><span class="lineNum">     114 </span>            :             isLessThanOrEqualTo: timestampEnd)</a>
<a name="115"><span class="lineNum">     115 </span><span class="lineNoCov">          0 :         .get();</span></a>
<a name="116"><span class="lineNum">     116 </span>            : </a>
<a name="117"><span class="lineNum">     117 </span>            :     // then merge everything into one single collection</a>
<a name="118"><span class="lineNum">     118 </span>            : </a>
<a name="119"><span class="lineNum">     119 </span><span class="lineNoCov">          0 :     Map&lt;String, Event&gt; eventsMap = {};</span></a>
<a name="120"><span class="lineNum">     120 </span>            : </a>
<a name="121"><span class="lineNum">     121 </span>            :     /// if QueryDocumentSnapshot ID field is not in Map</a>
<a name="122"><span class="lineNum">     122 </span><span class="lineNoCov">          0 :     bool idNotInMap(QueryDocumentSnapshot&lt;Map&lt;String, dynamic&gt;&gt; doc) {</span></a>
<a name="123"><span class="lineNum">     123 </span><span class="lineNoCov">          0 :       return !eventsMap.containsKey(doc.id);</span></a>
<a name="124"><span class="lineNum">     124 </span>            :     }</a>
<a name="125"><span class="lineNum">     125 </span>            : </a>
<a name="126"><span class="lineNum">     126 </span>            :     /// For a list of events, check if events of type QueryDocumentSnapshot satisfy a conditional that must take a QueryDocumentSnapshot, if not, add to map</a>
<a name="127"><span class="lineNum">     127 </span><span class="lineNoCov">          0 :     void checkAndAddEventToMap(</span></a>
<a name="128"><span class="lineNum">     128 </span>            :         QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; queriedEvents,</a>
<a name="129"><span class="lineNum">     129 </span>            :         bool Function(QueryDocumentSnapshot&lt;Map&lt;String, dynamic&gt;&gt;)</a>
<a name="130"><span class="lineNum">     130 </span>            :             conditionalFunction) {</a>
<a name="131"><span class="lineNum">     131 </span><span class="lineNoCov">          0 :       for (var doc in queriedEvents.docs) {</span></a>
<a name="132"><span class="lineNum">     132 </span><span class="lineNoCov">          0 :         if (conditionalFunction(doc)) {</span></a>
<a name="133"><span class="lineNum">     133 </span><span class="lineNoCov">          0 :           eventsMap[doc.id] = Event.fromMap(doc.data(), id: doc.id);</span></a>
<a name="134"><span class="lineNum">     134 </span>            :         }</a>
<a name="135"><span class="lineNum">     135 </span>            :       }</a>
<a name="136"><span class="lineNum">     136 </span>            :     }</a>
<a name="137"><span class="lineNum">     137 </span>            : </a>
<a name="138"><span class="lineNum">     138 </span>            :     // I can't chain iterables like in python, this is the best I can think of to prevent duplication</a>
<a name="139"><span class="lineNum">     139 </span><span class="lineNoCov">          0 :     checkAndAddEventToMap(eventsTimeStartInRange, idNotInMap);</span></a>
<a name="140"><span class="lineNum">     140 </span><span class="lineNoCov">          0 :     checkAndAddEventToMap(eventsTimeEndInRange, idNotInMap);</span></a>
<a name="141"><span class="lineNum">     141 </span>            : </a>
<a name="142"><span class="lineNum">     142 </span>            :     // there's also a risk of a super long event not being caught</a>
<a name="143"><span class="lineNum">     143 </span>            :     // this is probably expensive but I can't think of a better way to do this, so unless someone else</a>
<a name="144"><span class="lineNum">     144 </span>            :     // has an idea I'll do this for now</a>
<a name="145"><span class="lineNum">     145 </span><span class="lineNoCov">          0 :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; eventsLessThan = await users</span></a>
<a name="146"><span class="lineNum">     146 </span><span class="lineNoCov">          0 :         .doc(userid)</span></a>
<a name="147"><span class="lineNum">     147 </span><span class="lineNoCov">          0 :         .collection(&quot;events&quot;)</span></a>
<a name="148"><span class="lineNum">     148 </span><span class="lineNoCov">          0 :         .where(&quot;event time start&quot;, isLessThan: timestampStart)</span></a>
<a name="149"><span class="lineNum">     149 </span><span class="lineNoCov">          0 :         .get();</span></a>
<a name="150"><span class="lineNum">     150 </span><span class="lineNoCov">          0 :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; eventsGreaterThan = await users</span></a>
<a name="151"><span class="lineNum">     151 </span><span class="lineNoCov">          0 :         .doc(userid)</span></a>
<a name="152"><span class="lineNum">     152 </span><span class="lineNoCov">          0 :         .collection(&quot;events&quot;)</span></a>
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 :         .where(&quot;event time start&quot;, isGreaterThan: timestampEnd)</span></a>
<a name="154"><span class="lineNum">     154 </span><span class="lineNoCov">          0 :         .get();</span></a>
<a name="155"><span class="lineNum">     155 </span>            : </a>
<a name="156"><span class="lineNum">     156 </span>            :     // add the intersection of the two sets</a>
<a name="157"><span class="lineNum">     157 </span>            :     // by converting each into a set of IDs</a>
<a name="158"><span class="lineNum">     158 </span>            :     // This is a little ugly as a result of Dart disliking forEach</a>
<a name="159"><span class="lineNum">     159 </span>            :     Set&lt;String&gt; setLessThan = {};</a>
<a name="160"><span class="lineNum">     160 </span>            :     Set&lt;String&gt; setGreaterThan = {};</a>
<a name="161"><span class="lineNum">     161 </span><span class="lineNoCov">          0 :     for (var doc in eventsLessThan.docs) {</span></a>
<a name="162"><span class="lineNum">     162 </span><span class="lineNoCov">          0 :       setLessThan.add(doc.id);</span></a>
<a name="163"><span class="lineNum">     163 </span>            :     }</a>
<a name="164"><span class="lineNum">     164 </span><span class="lineNoCov">          0 :     for (var doc in eventsGreaterThan.docs) {</span></a>
<a name="165"><span class="lineNum">     165 </span><span class="lineNoCov">          0 :       setGreaterThan.add(doc.id);</span></a>
<a name="166"><span class="lineNum">     166 </span>            :     }</a>
<a name="167"><span class="lineNum">     167 </span>            : </a>
<a name="168"><span class="lineNum">     168 </span>            :     /// if QueryDocumentSnapshot in intersection of sets and not already added into map</a>
<a name="169"><span class="lineNum">     169 </span><span class="lineNoCov">          0 :     bool notInSetOrMap(QueryDocumentSnapshot&lt;Map&lt;String, dynamic&gt;&gt; doc) {</span></a>
<a name="170"><span class="lineNum">     170 </span><span class="lineNoCov">          0 :       return idNotInMap(doc) &amp;&amp;</span></a>
<a name="171"><span class="lineNum">     171 </span><span class="lineNoCov">          0 :           setLessThan.contains(doc.id) &amp;&amp;</span></a>
<a name="172"><span class="lineNum">     172 </span><span class="lineNoCov">          0 :           setGreaterThan.contains(doc.id);</span></a>
<a name="173"><span class="lineNum">     173 </span>            :     }</a>
<a name="174"><span class="lineNum">     174 </span>            : </a>
<a name="175"><span class="lineNum">     175 </span>            :     // and checking if the event exists in both sets</a>
<a name="176"><span class="lineNum">     176 </span><span class="lineNoCov">          0 :     checkAndAddEventToMap(eventsLessThan, notInSetOrMap);</span></a>
<a name="177"><span class="lineNum">     177 </span><span class="lineNoCov">          0 :     checkAndAddEventToMap(eventsGreaterThan, notInSetOrMap);</span></a>
<a name="178"><span class="lineNum">     178 </span>            :     return eventsMap;</a>
<a name="179"><span class="lineNum">     179 </span>            :   }</a>
<a name="180"><span class="lineNum">     180 </span>            : </a>
<a name="181"><span class="lineNum">     181 </span>            :   // Get list of all events within a date range</a>
<a name="182"><span class="lineNum">     182 </span><span class="lineNoCov">          0 :   Future&lt;List&lt;Event&gt;&gt; getListOfEventsInDateRange(</span></a>
<a name="183"><span class="lineNum">     183 </span>            :       {required DateTime dateStart, required DateTime dateEnd}) async {</a>
<a name="184"><span class="lineNum">     184 </span><span class="lineNoCov">          0 :     List&lt;Event&gt; events = [];</span></a>
<a name="185"><span class="lineNum">     185 </span>            :     final userEvents =</a>
<a name="186"><span class="lineNum">     186 </span><span class="lineNoCov">          0 :         await getEventsInDateRange(dateStart: dateStart, dateEnd: dateEnd);</span></a>
<a name="187"><span class="lineNum">     187 </span><span class="lineNoCov">          0 :     for (final event in userEvents.values) {</span></a>
<a name="188"><span class="lineNum">     188 </span><span class="lineNoCov">          0 :       events.add(event);</span></a>
<a name="189"><span class="lineNum">     189 </span>            :     }</a>
<a name="190"><span class="lineNum">     190 </span>            :     return events;</a>
<a name="191"><span class="lineNum">     191 </span>            :   }</a>
<a name="192"><span class="lineNum">     192 </span>            : </a>
<a name="193"><span class="lineNum">     193 </span>            :   /// Get all events in a day</a>
<a name="194"><span class="lineNum">     194 </span>            :   ///</a>
<a name="195"><span class="lineNum">     195 </span>            :   /// returns a Map</a>
<a name="196"><span class="lineNum">     196 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;String, Event&gt;&gt; getEventsInDay({required DateTime date}) async {</span></a>
<a name="197"><span class="lineNum">     197 </span>            :     DateTime tomorrow = date;</a>
<a name="198"><span class="lineNum">     198 </span><span class="lineNoCov">          0 :     tomorrow = tomorrow.add(const Duration(days: 1));</span></a>
<a name="199"><span class="lineNum">     199 </span><span class="lineNoCov">          0 :     return getEventsInDateRange(dateStart: date, dateEnd: tomorrow);</span></a>
<a name="200"><span class="lineNum">     200 </span>            :   }</a>
<a name="201"><span class="lineNum">     201 </span>            : </a>
<a name="202"><span class="lineNum">     202 </span>            :   /// Get list of events in a day</a>
<a name="203"><span class="lineNum">     203 </span><span class="lineNoCov">          0 :   Future&lt;List&lt;Event&gt;&gt; getListOfEventsInDay({required DateTime date}) async {</span></a>
<a name="204"><span class="lineNum">     204 </span>            :     DateTime tomorrow = date;</a>
<a name="205"><span class="lineNum">     205 </span><span class="lineNoCov">          0 :     tomorrow = tomorrow.add(const Duration(days: 1));</span></a>
<a name="206"><span class="lineNum">     206 </span><span class="lineNoCov">          0 :     return getListOfEventsInDateRange(dateStart: date, dateEnd: tomorrow);</span></a>
<a name="207"><span class="lineNum">     207 </span>            :   }</a>
<a name="208"><span class="lineNum">     208 </span>            : </a>
<a name="209"><span class="lineNum">     209 </span>            :   /// Change an option in the event</a>
<a name="210"><span class="lineNum">     210 </span>            :   ///</a>
<a name="211"><span class="lineNum">     211 </span>            :   /// needs a event ID and a map of the new option</a>
<a name="212"><span class="lineNum">     212 </span>            :   /// map ex: {&quot;optionName&quot;: &quot;optionValue&quot;}</a>
<a name="213"><span class="lineNum">     213 </span><span class="lineNoCov">          0 :   Future&lt;void&gt; updateEventOption(</span></a>
<a name="214"><span class="lineNum">     214 </span>            :       String eventID, Map&lt;String, dynamic&gt; newOptions) async {</a>
<a name="215"><span class="lineNum">     215 </span><span class="lineNoCov">          0 :     return users</span></a>
<a name="216"><span class="lineNum">     216 </span><span class="lineNoCov">          0 :         .doc(userid)</span></a>
<a name="217"><span class="lineNum">     217 </span><span class="lineNoCov">          0 :         .collection(&quot;events&quot;)</span></a>
<a name="218"><span class="lineNum">     218 </span><span class="lineNoCov">          0 :         .doc(eventID)</span></a>
<a name="219"><span class="lineNum">     219 </span><span class="lineNoCov">          0 :         .update(newOptions);</span></a>
<a name="220"><span class="lineNum">     220 </span>            :   }</a>
<a name="221"><span class="lineNum">     221 </span>            : </a>
<a name="222"><span class="lineNum">     222 </span>            :   /// Check if an event exists in the db</a>
<a name="223"><span class="lineNum">     223 </span><span class="lineNoCov">          0 :   Future&lt;bool&gt; checkIfEventExists(String eventID) async {</span></a>
<a name="224"><span class="lineNum">     224 </span>            :     // firestore doesn't have a built in function? are we expected to maintain this locally?</a>
<a name="225"><span class="lineNum">     225 </span>            :     try {</a>
<a name="226"><span class="lineNum">     226 </span>            :       final event =</a>
<a name="227"><span class="lineNum">     227 </span><span class="lineNoCov">          0 :           await users.doc(userid).collection(&quot;events&quot;).doc(eventID).get();</span></a>
<a name="228"><span class="lineNum">     228 </span><span class="lineNoCov">          0 :       return event.exists;</span></a>
<a name="229"><span class="lineNum">     229 </span>            :     } catch (e) {</a>
<a name="230"><span class="lineNum">     230 </span>            :       return false;</a>
<a name="231"><span class="lineNum">     231 </span>            :     }</a>
<a name="232"><span class="lineNum">     232 </span>            :   }</a>
<a name="233"><span class="lineNum">     233 </span>            : </a>
<a name="234"><span class="lineNum">     234 </span>            :   /// add all recurring events in the database</a>
<a name="235"><span class="lineNum">     235 </span><span class="lineNoCov">          0 :   Future&lt;void&gt; setRecurringEvents(Event e) async {</span></a>
<a name="236"><span class="lineNum">     236 </span><span class="lineNoCov">          0 :     List&lt;Event&gt; recurringEvents = e.generateRecurringEvents();</span></a>
<a name="237"><span class="lineNum">     237 </span><span class="lineNoCov">          0 :     for (final e in recurringEvents) {</span></a>
<a name="238"><span class="lineNum">     238 </span><span class="lineNoCov">          0 :       await addEvent(e);</span></a>
<a name="239"><span class="lineNum">     239 </span>            :     }</a>
<a name="240"><span class="lineNum">     240 </span>            :   }</a>
<a name="241"><span class="lineNum">     241 </span>            : </a>
<a name="242"><span class="lineNum">     242 </span>            :   /// delete all recurring events in the database given a base event</a>
<a name="243"><span class="lineNum">     243 </span><span class="lineNoCov">          0 :   Future&lt;void&gt; deleteRecurringEvents(Event e) async {</span></a>
<a name="244"><span class="lineNum">     244 </span>            :     // guard case, no recurrence then don't do anything</a>
<a name="245"><span class="lineNum">     245 </span><span class="lineNoCov">          0 :     if (e.recurrenceRules.enabled == false) {</span></a>
<a name="246"><span class="lineNum">     246 </span>            :       return;</a>
<a name="247"><span class="lineNum">     247 </span>            :     }</a>
<a name="248"><span class="lineNum">     248 </span><span class="lineNoCov">          0 :     List&lt;DateTime&gt; dts = e.getDatesOfRelatedRecurringEvents();</span></a>
<a name="249"><span class="lineNum">     249 </span><span class="lineNoCov">          0 :     final parentID = e.recurrenceRules.id;</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineNoCov">          0 :     for (final dt in dts) {</span></a>
<a name="251"><span class="lineNum">     251 </span>            :       // search the database for event on this date</a>
<a name="252"><span class="lineNum">     252 </span><span class="lineNoCov">          0 :       final Map&lt;String, Event&gt; eventList = await getEventsInDay(date: dt);</span></a>
<a name="253"><span class="lineNum">     253 </span>            :       // search the corresponding events on that day for the right recurrence ID</a>
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :       eventList.forEach((docID, event) {</span></a>
<a name="255"><span class="lineNum">     255 </span><span class="lineNoCov">          0 :         if (event.recurrenceRules.id == parentID) {</span></a>
<a name="256"><span class="lineNum">     256 </span>            :           // if the recurrence ID matches, delete</a>
<a name="257"><span class="lineNum">     257 </span><span class="lineNoCov">          0 :           users.doc(userid).collection(&quot;events&quot;).doc(docID).delete();</span></a>
<a name="258"><span class="lineNum">     258 </span>            :         }</a>
<a name="259"><span class="lineNum">     259 </span>            :       });</a>
<a name="260"><span class="lineNum">     260 </span>            :     }</a>
<a name="261"><span class="lineNum">     261 </span>            :   }</a>
<a name="262"><span class="lineNum">     262 </span>            : </a>
<a name="263"><span class="lineNum">     263 </span>            : ////////////////////////////////////////////////////</a>
<a name="264"><span class="lineNum">     264 </span>            : </a>
<a name="265"><span class="lineNum">     265 </span><span class="lineNoCov">          0 :   Future&lt;Task&gt; getTask(String taskID) async {</span></a>
<a name="266"><span class="lineNum">     266 </span>            :     try {</a>
<a name="267"><span class="lineNum">     267 </span>            :       DocumentSnapshot&lt;Map&lt;String, dynamic&gt;&gt; taskDocument =</a>
<a name="268"><span class="lineNum">     268 </span><span class="lineNoCov">          0 :           await users.doc(userid).collection('tasks').doc(taskID).get();</span></a>
<a name="269"><span class="lineNum">     269 </span><span class="lineNoCov">          0 :       if (taskDocument.exists) {</span></a>
<a name="270"><span class="lineNum">     270 </span><span class="lineNoCov">          0 :         return Task.fromMap(taskDocument.data() ?? {&quot;getTask Error&quot;: 1},</span></a>
<a name="271"><span class="lineNum">     271 </span><span class="lineNoCov">          0 :             id: taskDocument.id);</span></a>
<a name="272"><span class="lineNum">     272 </span>            :       }</a>
<a name="273"><span class="lineNum">     273 </span>            :     } catch (e) {</a>
<a name="274"><span class="lineNum">     274 </span>            :       rethrow;</a>
<a name="275"><span class="lineNum">     275 </span>            :     }</a>
<a name="276"><span class="lineNum">     276 </span><span class="lineNoCov">          0 :     throw Exception(&quot;Task not found&quot;);</span></a>
<a name="277"><span class="lineNum">     277 </span>            :   }</a>
<a name="278"><span class="lineNum">     278 </span>            : </a>
<a name="279"><span class="lineNum">     279 </span><span class="lineNoCov">          0 :   Future&lt;List&lt;Task&gt;&gt; getTasksOfName(String taskName) async {</span></a>
<a name="280"><span class="lineNum">     280 </span><span class="lineNoCov">          0 :     final allTasks = await users</span></a>
<a name="281"><span class="lineNum">     281 </span><span class="lineNoCov">          0 :         .doc(userid)</span></a>
<a name="282"><span class="lineNum">     282 </span><span class="lineNoCov">          0 :         .collection(&quot;tasks&quot;)</span></a>
<a name="283"><span class="lineNum">     283 </span><span class="lineNoCov">          0 :         .where(&quot;task name&quot;, isEqualTo: taskName)</span></a>
<a name="284"><span class="lineNum">     284 </span><span class="lineNoCov">          0 :         .get();</span></a>
<a name="285"><span class="lineNum">     285 </span>            : </a>
<a name="286"><span class="lineNum">     286 </span><span class="lineNoCov">          0 :     List&lt;Task&gt; listOfTasks = [];</span></a>
<a name="287"><span class="lineNum">     287 </span><span class="lineNoCov">          0 :     for (var doc in allTasks.docs) {</span></a>
<a name="288"><span class="lineNum">     288 </span><span class="lineNoCov">          0 :       Task t = Task.fromMap(doc.data(), id: doc.id);</span></a>
<a name="289"><span class="lineNum">     289 </span><span class="lineNoCov">          0 :       listOfTasks.add(t);</span></a>
<a name="290"><span class="lineNum">     290 </span>            :     }</a>
<a name="291"><span class="lineNum">     291 </span>            : </a>
<a name="292"><span class="lineNum">     292 </span>            :     return listOfTasks;</a>
<a name="293"><span class="lineNum">     293 </span>            :   }</a>
<a name="294"><span class="lineNum">     294 </span>            : </a>
<a name="295"><span class="lineNum">     295 </span>            :   /// Saves a task into the database</a>
<a name="296"><span class="lineNum">     296 </span><span class="lineCov">          2 :   Future&lt;void&gt; setTask(Task t) async {</span></a>
<a name="297"><span class="lineNum">     297 </span><span class="lineCov">         16 :     return await users.doc(userid).collection('tasks').doc(t.id).set(t.toMap());</span></a>
<a name="298"><span class="lineNum">     298 </span>            :   }</a>
<a name="299"><span class="lineNum">     299 </span>            : </a>
<a name="300"><span class="lineNum">     300 </span>            :   /// Deletes a task from the database</a>
<a name="301"><span class="lineNum">     301 </span><span class="lineCov">          1 :   Future&lt;void&gt; deleteTask(Task t) async {</span></a>
<a name="302"><span class="lineNum">     302 </span><span class="lineCov">          7 :     return await users.doc(userid).collection('tasks').doc(t.id).delete();</span></a>
<a name="303"><span class="lineNum">     303 </span>            :   }</a>
<a name="304"><span class="lineNum">     304 </span>            : </a>
<a name="305"><span class="lineNum">     305 </span>            :   /// Returns a pair of lists of the form (active tasks, completed tasks)</a>
<a name="306"><span class="lineNum">     306 </span>            :   /// where task.timeCureent is in a date range [dateStart, dateEnd) for all tasks in either list</a>
<a name="307"><span class="lineNum">     307 </span><span class="lineCov">          1 :   Future&lt;(List&lt;Task&gt;, List&lt;Task&gt;)&gt; _getTasksActiveOrCompleted(</span></a>
<a name="308"><span class="lineNum">     308 </span>            :       DateTime dateStart, DateTime dateEnd) async {</a>
<a name="309"><span class="lineNum">     309 </span><span class="lineCov">          1 :     Timestamp timestampStart = Timestamp.fromDate(dateStart);</span></a>
<a name="310"><span class="lineNum">     310 </span><span class="lineCov">          1 :     Timestamp timestampEnd = Timestamp.fromDate(dateEnd);</span></a>
<a name="311"><span class="lineNum">     311 </span><span class="lineCov">          1 :     QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; allTasks = await users</span></a>
<a name="312"><span class="lineNum">     312 </span><span class="lineCov">          2 :         .doc(userid)</span></a>
<a name="313"><span class="lineNum">     313 </span><span class="lineCov">          1 :         .collection(&quot;tasks&quot;)</span></a>
<a name="314"><span class="lineNum">     314 </span><span class="lineCov">          1 :         .where(&quot;current date&quot;,</span></a>
<a name="315"><span class="lineNum">     315 </span>            :             isGreaterThanOrEqualTo: timestampStart, isLessThan: timestampEnd)</a>
<a name="316"><span class="lineNum">     316 </span><span class="lineCov">          1 :         .get();</span></a>
<a name="317"><span class="lineNum">     317 </span>            : </a>
<a name="318"><span class="lineNum">     318 </span><span class="lineCov">          1 :     List&lt;Task&gt; activeList = [];</span></a>
<a name="319"><span class="lineNum">     319 </span><span class="lineCov">          1 :     List&lt;Task&gt; completedList = [];</span></a>
<a name="320"><span class="lineNum">     320 </span><span class="lineCov">          2 :     for (var doc in allTasks.docs) {</span></a>
<a name="321"><span class="lineNum">     321 </span><span class="lineCov">          3 :       Task t = Task.fromMap(doc.data(), id: doc.id);</span></a>
<a name="322"><span class="lineNum">     322 </span><span class="lineCov">          1 :       if (t.completed) {</span></a>
<a name="323"><span class="lineNum">     323 </span><span class="lineCov">          1 :         completedList.add(t);</span></a>
<a name="324"><span class="lineNum">     324 </span>            :       } else {</a>
<a name="325"><span class="lineNum">     325 </span><span class="lineCov">          1 :         activeList.add(t);</span></a>
<a name="326"><span class="lineNum">     326 </span>            :       }</a>
<a name="327"><span class="lineNum">     327 </span>            :     }</a>
<a name="328"><span class="lineNum">     328 </span>            : </a>
<a name="329"><span class="lineNum">     329 </span>            :     return (activeList, completedList);</a>
<a name="330"><span class="lineNum">     330 </span>            :   }</a>
<a name="331"><span class="lineNum">     331 </span>            : </a>
<a name="332"><span class="lineNum">     332 </span>            :   /// All tasks that have a delay in the window [dateStart, dateEnd)</a>
<a name="333"><span class="lineNum">     333 </span>            :   /// Returns a list of tasks with delays in the time window in order of current date</a>
<a name="334"><span class="lineNum">     334 </span><span class="lineCov">          1 :   Future&lt;List&lt;Task&gt;&gt; _getTasksDelayed(</span></a>
<a name="335"><span class="lineNum">     335 </span>            :       DateTime dateStart, DateTime dateEnd) async {</a>
<a name="336"><span class="lineNum">     336 </span><span class="lineCov">          1 :     Timestamp timestampStart = Timestamp.fromDate(dateStart);</span></a>
<a name="337"><span class="lineNum">     337 </span><span class="lineCov">          1 :     QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; candidateTasks = await users</span></a>
<a name="338"><span class="lineNum">     338 </span><span class="lineCov">          2 :         .doc(userid)</span></a>
<a name="339"><span class="lineNum">     339 </span><span class="lineCov">          1 :         .collection(&quot;tasks&quot;)</span></a>
<a name="340"><span class="lineNum">     340 </span><span class="lineCov">          1 :         .where(&quot;current date&quot;, isGreaterThanOrEqualTo: timestampStart)</span></a>
<a name="341"><span class="lineNum">     341 </span>            :         // .where(&quot;time start&quot;,</a>
<a name="342"><span class="lineNum">     342 </span>            :         //         isLessThan: timestampEnd) // firebase cant do 2 field where()'s</a>
<a name="343"><span class="lineNum">     343 </span><span class="lineCov">          1 :         .get();</span></a>
<a name="344"><span class="lineNum">     344 </span>            : </a>
<a name="345"><span class="lineNum">     345 </span><span class="lineCov">          1 :     List&lt;Task&gt; delayedList = [];</span></a>
<a name="346"><span class="lineNum">     346 </span><span class="lineCov">          2 :     for (var doc in candidateTasks.docs) {</span></a>
<a name="347"><span class="lineNum">     347 </span><span class="lineCov">          3 :       if ((doc['time start'] as Timestamp).toDate().isBefore(dateEnd)) {</span></a>
<a name="348"><span class="lineNum">     348 </span><span class="lineCov">          3 :         Task t = Task.fromMap(doc.data(), id: doc.id);</span></a>
<a name="349"><span class="lineNum">     349 </span><span class="lineCov">          2 :         DateTime startDay = getDateOnly(t.timeStart);</span></a>
<a name="350"><span class="lineNum">     350 </span><span class="lineCov">          2 :         DateTime currentDay = getDateOnly(t.timeCurrent);</span></a>
<a name="351"><span class="lineNum">     351 </span><span class="lineCov">          1 :         if (startDay.isBefore(currentDay)) {</span></a>
<a name="352"><span class="lineNum">     352 </span><span class="lineCov">          1 :           delayedList.add(t);</span></a>
<a name="353"><span class="lineNum">     353 </span>            :         }</a>
<a name="354"><span class="lineNum">     354 </span>            :       }</a>
<a name="355"><span class="lineNum">     355 </span>            :     }</a>
<a name="356"><span class="lineNum">     356 </span>            : </a>
<a name="357"><span class="lineNum">     357 </span>            :     return delayedList;</a>
<a name="358"><span class="lineNum">     358 </span>            :   }</a>
<a name="359"><span class="lineNum">     359 </span>            : </a>
<a name="360"><span class="lineNum">     360 </span>            :   /// Returns a 3-tuple of Maps&lt;DateTime, List&lt;Task&gt;&gt; where each map goes from [dateStart, dateEnd)</a>
<a name="361"><span class="lineNum">     361 </span>            :   /// Values are lists of tasks that are either active, completed, or delayed on a day</a>
<a name="362"><span class="lineNum">     362 </span>            :   /// Takes the form (ActiveMap, CompletedMap, DelayedMap)</a>
<a name="363"><span class="lineNum">     363 </span><span class="lineCov">          1 :   Future&lt;</span></a>
<a name="364"><span class="lineNum">     364 </span>            :       (</a>
<a name="365"><span class="lineNum">     365 </span>            :         Map&lt;DateTime, List&lt;Task&gt;&gt;,</a>
<a name="366"><span class="lineNum">     366 </span>            :         Map&lt;DateTime, List&lt;Task&gt;&gt;,</a>
<a name="367"><span class="lineNum">     367 </span>            :         Map&lt;DateTime, List&lt;Task&gt;&gt;</a>
<a name="368"><span class="lineNum">     368 </span>            :       )&gt; getTaskMaps(DateTime dateStart, DateTime dateEnd) async {</a>
<a name="369"><span class="lineNum">     369 </span><span class="lineCov">          1 :     dateStart = getDateOnly(dateStart);</span></a>
<a name="370"><span class="lineNum">     370 </span><span class="lineCov">          1 :     dateEnd = getDateOnly(dateEnd);</span></a>
<a name="371"><span class="lineNum">     371 </span><span class="lineCov">          1 :     verifyDateStartEnd(dateStart, dateEnd);</span></a>
<a name="372"><span class="lineNum">     372 </span>            : </a>
<a name="373"><span class="lineNum">     373 </span><span class="lineCov">          1 :     Map&lt;DateTime, List&lt;Task&gt;&gt; activeMap = {};</span></a>
<a name="374"><span class="lineNum">     374 </span><span class="lineCov">          1 :     Map&lt;DateTime, List&lt;Task&gt;&gt; completedMap = {};</span></a>
<a name="375"><span class="lineNum">     375 </span><span class="lineCov">          1 :     Map&lt;DateTime, List&lt;Task&gt;&gt; delayedMap = {};</span></a>
<a name="376"><span class="lineNum">     376 </span><span class="lineCov">          4 :     for (int i = 0; i &lt; dateEnd.difference(dateStart).inDays; i++) {</span></a>
<a name="377"><span class="lineNum">     377 </span><span class="lineCov">          1 :       DateTime newDay = getDateOnly(dateStart, offsetDays: i);</span></a>
<a name="378"><span class="lineNum">     378 </span><span class="lineCov">          2 :       activeMap[newDay] = [];</span></a>
<a name="379"><span class="lineNum">     379 </span><span class="lineCov">          2 :       completedMap[newDay] = [];</span></a>
<a name="380"><span class="lineNum">     380 </span><span class="lineCov">          2 :       delayedMap[newDay] = [];</span></a>
<a name="381"><span class="lineNum">     381 </span>            :     }</a>
<a name="382"><span class="lineNum">     382 </span>            : </a>
<a name="383"><span class="lineNum">     383 </span>            :     List&lt;Task&gt; activeList, completedList;</a>
<a name="384"><span class="lineNum">     384 </span><span class="lineNoCov">          0 :     (activeList, completedList) =</span></a>
<a name="385"><span class="lineNum">     385 </span><span class="lineCov">          1 :         await _getTasksActiveOrCompleted(dateStart, dateEnd);</span></a>
<a name="386"><span class="lineNum">     386 </span>            : </a>
<a name="387"><span class="lineNum">     387 </span><span class="lineCov">          2 :     for (Task t in activeList) {</span></a>
<a name="388"><span class="lineNum">     388 </span><span class="lineCov">          2 :       DateTime currentDay = getDateOnly(t.timeCurrent);</span></a>
<a name="389"><span class="lineNum">     389 </span><span class="lineCov">          1 :       if (activeMap[currentDay] == null) {</span></a>
<a name="390"><span class="lineNum">     390 </span>            :         continue;</a>
<a name="391"><span class="lineNum">     391 </span>            :       }</a>
<a name="392"><span class="lineNum">     392 </span><span class="lineCov">          2 :       activeMap[currentDay]!.add(t);</span></a>
<a name="393"><span class="lineNum">     393 </span>            :     }</a>
<a name="394"><span class="lineNum">     394 </span><span class="lineCov">          2 :     for (Task t in completedList) {</span></a>
<a name="395"><span class="lineNum">     395 </span><span class="lineCov">          2 :       DateTime currentDay = getDateOnly(t.timeCurrent);</span></a>
<a name="396"><span class="lineNum">     396 </span><span class="lineCov">          1 :       if (completedMap[currentDay] == null) {</span></a>
<a name="397"><span class="lineNum">     397 </span>            :         continue;</a>
<a name="398"><span class="lineNum">     398 </span>            :       }</a>
<a name="399"><span class="lineNum">     399 </span><span class="lineCov">          2 :       completedMap[currentDay]!.add(t);</span></a>
<a name="400"><span class="lineNum">     400 </span>            :     }</a>
<a name="401"><span class="lineNum">     401 </span>            : </a>
<a name="402"><span class="lineNum">     402 </span><span class="lineCov">          1 :     List&lt;Task&gt; delayList = await _getTasksDelayed(dateStart, dateEnd);</span></a>
<a name="403"><span class="lineNum">     403 </span><span class="lineCov">          2 :     for (Task t in delayList) {</span></a>
<a name="404"><span class="lineNum">     404 </span>            :       DateTime loopStart =</a>
<a name="405"><span class="lineNum">     405 </span><span class="lineCov">          3 :           t.timeStart.isBefore(dateStart) ? dateStart : t.timeStart;</span></a>
<a name="406"><span class="lineNum">     406 </span>            :       DateTime loopEnd =</a>
<a name="407"><span class="lineNum">     407 </span><span class="lineCov">          3 :           t.timeCurrent.isBefore(dateEnd) ? t.timeCurrent : dateEnd;</span></a>
<a name="408"><span class="lineNum">     408 </span><span class="lineCov">          1 :       loopStart = getDateOnly(loopStart);</span></a>
<a name="409"><span class="lineNum">     409 </span><span class="lineCov">          1 :       loopEnd = getDateOnly(loopEnd);</span></a>
<a name="410"><span class="lineNum">     410 </span><span class="lineCov">          4 :       for (int i = 0; i &lt; loopEnd.difference(loopStart).inDays; i++) {</span></a>
<a name="411"><span class="lineNum">     411 </span><span class="lineCov">          1 :         DateTime date = getDateOnly(loopStart, offsetDays: i);</span></a>
<a name="412"><span class="lineNum">     412 </span><span class="lineCov">          1 :         if (delayedMap[date] == null) {</span></a>
<a name="413"><span class="lineNum">     413 </span>            :           continue;</a>
<a name="414"><span class="lineNum">     414 </span>            :         }</a>
<a name="415"><span class="lineNum">     415 </span><span class="lineCov">          2 :         delayedMap[date]!.add(t);</span></a>
<a name="416"><span class="lineNum">     416 </span>            :       }</a>
<a name="417"><span class="lineNum">     417 </span>            :     }</a>
<a name="418"><span class="lineNum">     418 </span>            :     return (activeMap, completedMap, delayedMap);</a>
<a name="419"><span class="lineNum">     419 </span>            :   }</a>
<a name="420"><span class="lineNum">     420 </span>            : </a>
<a name="421"><span class="lineNum">     421 </span>            :   /// Returns a 3-tuple of List&lt;Task&gt;</a>
<a name="422"><span class="lineNum">     422 </span>            :   /// Each list has tasks that are either active, completed, or delayed in a time window</a>
<a name="423"><span class="lineNum">     423 </span><span class="lineCov">          1 :   Future&lt;(List&lt;Task&gt;, List&lt;Task&gt;, List&lt;Task&gt;)&gt; getTaskMapsDay(</span></a>
<a name="424"><span class="lineNum">     424 </span>            :       DateTime dateStart) async {</a>
<a name="425"><span class="lineNum">     425 </span><span class="lineCov">          1 :     dateStart = getDateOnly(dateStart);</span></a>
<a name="426"><span class="lineNum">     426 </span>            : </a>
<a name="427"><span class="lineNum">     427 </span>            :     Map&lt;DateTime, List&lt;Task&gt;&gt; dayActiveMap, dayCompMap, dayDelayMap;</a>
<a name="428"><span class="lineNum">     428 </span><span class="lineNoCov">          0 :     (dayActiveMap, dayCompMap, dayDelayMap) =</span></a>
<a name="429"><span class="lineNum">     429 </span><span class="lineCov">          2 :         await getTaskMaps(dateStart, getDateOnly(dateStart, offsetDays: 1));</span></a>
<a name="430"><span class="lineNum">     430 </span>            : </a>
<a name="431"><span class="lineNum">     431 </span>            :     return (</a>
<a name="432"><span class="lineNum">     432 </span><span class="lineCov">          1 :       dayActiveMap[dateStart] ?? [],</span></a>
<a name="433"><span class="lineNum">     433 </span><span class="lineCov">          1 :       dayCompMap[dateStart] ?? [],</span></a>
<a name="434"><span class="lineNum">     434 </span><span class="lineCov">          1 :       dayDelayMap[dateStart] ?? []</span></a>
<a name="435"><span class="lineNum">     435 </span>            :     );</a>
<a name="436"><span class="lineNum">     436 </span>            :   }</a>
<a name="437"><span class="lineNum">     437 </span>            : </a>
<a name="438"><span class="lineNum">     438 </span>            :   /// Returns a 3-tuple of Maps&lt;DateTime, List&lt;Task&gt;&gt; where each map goes from 1 week from dateStart</a>
<a name="439"><span class="lineNum">     439 </span>            :   /// Each map has lists of tasks that are either active, completed, or delayed on a day</a>
<a name="440"><span class="lineNum">     440 </span><span class="lineCov">          1 :   Future&lt;</span></a>
<a name="441"><span class="lineNum">     441 </span>            :       (</a>
<a name="442"><span class="lineNum">     442 </span>            :         Map&lt;DateTime, List&lt;Task&gt;&gt;,</a>
<a name="443"><span class="lineNum">     443 </span>            :         Map&lt;DateTime, List&lt;Task&gt;&gt;,</a>
<a name="444"><span class="lineNum">     444 </span>            :         Map&lt;DateTime, List&lt;Task&gt;&gt;</a>
<a name="445"><span class="lineNum">     445 </span>            :       )&gt; getTaskMapsWeek(DateTime dateStart) async {</a>
<a name="446"><span class="lineNum">     446 </span>            :     int daysToNextWeek = 7;</a>
<a name="447"><span class="lineNum">     447 </span><span class="lineCov">          1 :     DateTime oneWeekLater = getDateOnly(dateStart, offsetDays: daysToNextWeek);</span></a>
<a name="448"><span class="lineNum">     448 </span><span class="lineCov">          1 :     return await getTaskMaps(dateStart, oneWeekLater);</span></a>
<a name="449"><span class="lineNum">     449 </span>            :   }</a>
<a name="450"><span class="lineNum">     450 </span>            : </a>
<a name="451"><span class="lineNum">     451 </span>            :   /// Returns a 3-tuple of Maps&lt;DateTime, List&lt;Task&gt;&gt; where each map goes from 1 month from dateStart</a>
<a name="452"><span class="lineNum">     452 </span>            :   /// Each map has lists of tasks that are either active, completed, or delayed on a day</a>
<a name="453"><span class="lineNum">     453 </span><span class="lineCov">          1 :   Future&lt;</span></a>
<a name="454"><span class="lineNum">     454 </span>            :       (</a>
<a name="455"><span class="lineNum">     455 </span>            :         Map&lt;DateTime, List&lt;Task&gt;&gt;,</a>
<a name="456"><span class="lineNum">     456 </span>            :         Map&lt;DateTime, List&lt;Task&gt;&gt;,</a>
<a name="457"><span class="lineNum">     457 </span>            :         Map&lt;DateTime, List&lt;Task&gt;&gt;</a>
<a name="458"><span class="lineNum">     458 </span>            :       )&gt; getTaskMapsMonth(DateTime dateStart) async {</a>
<a name="459"><span class="lineNum">     459 </span>            :     DateTime nextMonth =</a>
<a name="460"><span class="lineNum">     460 </span><span class="lineCov">          5 :         DateTime(dateStart.year, dateStart.month + 1, dateStart.day);</span></a>
<a name="461"><span class="lineNum">     461 </span><span class="lineCov">          1 :     return getTaskMaps(dateStart, nextMonth);</span></a>
<a name="462"><span class="lineNum">     462 </span>            :   }</a>
<a name="463"><span class="lineNum">     463 </span>            : </a>
<a name="464"><span class="lineNum">     464 </span>            :   /// All tasks that are due in the time window [dateStart, dateEnd)</a>
<a name="465"><span class="lineNum">     465 </span>            :   /// Returns a map from each day in the window to a list of tasks due that day</a>
<a name="466"><span class="lineNum">     466 </span><span class="lineCov">          1 :   Future&lt;Map&lt;DateTime, List&lt;Task&gt;&gt;&gt; getTasksDue(</span></a>
<a name="467"><span class="lineNum">     467 </span>            :       DateTime dateStart, DateTime dateEnd) async {</a>
<a name="468"><span class="lineNum">     468 </span><span class="lineCov">          1 :     dateStart = getDateOnly(dateStart);</span></a>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">          1 :     dateEnd = getDateOnly(dateEnd);</span></a>
<a name="470"><span class="lineNum">     470 </span><span class="lineCov">          1 :     verifyDateStartEnd(dateStart, dateEnd);</span></a>
<a name="471"><span class="lineNum">     471 </span>            : </a>
<a name="472"><span class="lineNum">     472 </span><span class="lineCov">          1 :     Timestamp timestampStart = Timestamp.fromDate(dateStart);</span></a>
<a name="473"><span class="lineNum">     473 </span><span class="lineCov">          1 :     Timestamp timestampEnd = Timestamp.fromDate(dateEnd);</span></a>
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">          1 :     QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; allTasksDue = await users</span></a>
<a name="475"><span class="lineNum">     475 </span><span class="lineCov">          2 :         .doc(userid)</span></a>
<a name="476"><span class="lineNum">     476 </span><span class="lineCov">          1 :         .collection(&quot;tasks&quot;)</span></a>
<a name="477"><span class="lineNum">     477 </span><span class="lineCov">          1 :         .where(&quot;time due&quot;,</span></a>
<a name="478"><span class="lineNum">     478 </span>            :             isGreaterThanOrEqualTo: timestampStart, isLessThan: timestampEnd)</a>
<a name="479"><span class="lineNum">     479 </span><span class="lineCov">          1 :         .get();</span></a>
<a name="480"><span class="lineNum">     480 </span>            : </a>
<a name="481"><span class="lineNum">     481 </span><span class="lineCov">          1 :     Map&lt;DateTime, List&lt;Task&gt;&gt; dueDateMap = {};</span></a>
<a name="482"><span class="lineNum">     482 </span><span class="lineCov">          4 :     for (int i = 0; i &lt; dateEnd.difference(dateStart).inDays; i++) {</span></a>
<a name="483"><span class="lineNum">     483 </span><span class="lineCov">          1 :       DateTime newDay = getDateOnly(dateStart, offsetDays: i);</span></a>
<a name="484"><span class="lineNum">     484 </span><span class="lineCov">          2 :       dueDateMap[newDay] = [];</span></a>
<a name="485"><span class="lineNum">     485 </span>            :     }</a>
<a name="486"><span class="lineNum">     486 </span>            : </a>
<a name="487"><span class="lineNum">     487 </span><span class="lineCov">          2 :     for (var doc in allTasksDue.docs) {</span></a>
<a name="488"><span class="lineNum">     488 </span><span class="lineCov">          3 :       Task t = Task.fromMap(doc.data(), id: doc.id);</span></a>
<a name="489"><span class="lineNum">     489 </span><span class="lineCov">          1 :       if (t.timeDue == null) continue;</span></a>
<a name="490"><span class="lineNum">     490 </span>            :       DateTime dueDate =</a>
<a name="491"><span class="lineNum">     491 </span><span class="lineCov">          2 :           getDateOnly(t.timeDue ?? dateStart); // ?? datestart forced by dart</span></a>
<a name="492"><span class="lineNum">     492 </span><span class="lineCov">          2 :       dueDateMap[dueDate]?.add(t);</span></a>
<a name="493"><span class="lineNum">     493 </span>            :     }</a>
<a name="494"><span class="lineNum">     494 </span>            : </a>
<a name="495"><span class="lineNum">     495 </span>            :     return dueDateMap;</a>
<a name="496"><span class="lineNum">     496 </span>            :   }</a>
<a name="497"><span class="lineNum">     497 </span>            : </a>
<a name="498"><span class="lineNum">     498 </span>            : ////////////////////////////////////////////////////</a>
<a name="499"><span class="lineNum">     499 </span>            : </a>
<a name="500"><span class="lineNum">     500 </span>            :   // Updates an existing tag, or creates a new tag if it doesn't exist</a>
<a name="501"><span class="lineNum">     501 </span>            :   // Takes in a Tag object</a>
<a name="502"><span class="lineNum">     502 </span><span class="lineCov">          1 :   Future&lt;void&gt; setTag(Tag tag) async {</span></a>
<a name="503"><span class="lineNum">     503 </span><span class="lineCov">          1 :     return await users</span></a>
<a name="504"><span class="lineNum">     504 </span><span class="lineCov">          2 :         .doc(userid)</span></a>
<a name="505"><span class="lineNum">     505 </span><span class="lineCov">          1 :         .collection(&quot;tags&quot;)</span></a>
<a name="506"><span class="lineNum">     506 </span><span class="lineCov">          2 :         .doc(tag.id)</span></a>
<a name="507"><span class="lineNum">     507 </span><span class="lineCov">          2 :         .set(tag.toMap());</span></a>
<a name="508"><span class="lineNum">     508 </span>            :   }</a>
<a name="509"><span class="lineNum">     509 </span>            : </a>
<a name="510"><span class="lineNum">     510 </span>            :   // Get a tag from the database by ID</a>
<a name="511"><span class="lineNum">     511 </span><span class="lineCov">          1 :   Future&lt;Tag&gt; getTag(String tagID) async {</span></a>
<a name="512"><span class="lineNum">     512 </span>            :     DocumentSnapshot&lt;Map&lt;String, dynamic&gt;&gt; tagDocument =</a>
<a name="513"><span class="lineNum">     513 </span><span class="lineCov">          6 :         await users.doc(userid).collection('tags').doc(tagID).get();</span></a>
<a name="514"><span class="lineNum">     514 </span><span class="lineCov">          1 :     if (tagDocument.exists) {</span></a>
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">          1 :       var tagMap = tagDocument.data() ?? {&quot;getTag Error&quot;: 1};</span></a>
<a name="516"><span class="lineNum">     516 </span><span class="lineCov">          1 :       return Tag.fromMap(tagMap);</span></a>
<a name="517"><span class="lineNum">     517 </span>            :     } else {</a>
<a name="518"><span class="lineNum">     518 </span><span class="lineNoCov">          0 :       throw Exception(&quot;Tag not found&quot;);</span></a>
<a name="519"><span class="lineNum">     519 </span>            :     }</a>
<a name="520"><span class="lineNum">     520 </span>            :   }</a>
<a name="521"><span class="lineNum">     521 </span>            : </a>
<a name="522"><span class="lineNum">     522 </span>            :   // Get a tag from the database by name</a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">          1 :   Future&lt;Tag&gt; getTagByName(String tagName) async {</span></a>
<a name="524"><span class="lineNum">     524 </span>            :     try {</a>
<a name="525"><span class="lineNum">     525 </span>            :       // get all tags with the name tagName</a>
<a name="526"><span class="lineNum">     526 </span><span class="lineCov">          1 :       var query = await users</span></a>
<a name="527"><span class="lineNum">     527 </span><span class="lineCov">          2 :           .doc(userid)</span></a>
<a name="528"><span class="lineNum">     528 </span><span class="lineCov">          1 :           .collection('tags')</span></a>
<a name="529"><span class="lineNum">     529 </span><span class="lineCov">          1 :           .where(&quot;name&quot;, isEqualTo: tagName)</span></a>
<a name="530"><span class="lineNum">     530 </span><span class="lineCov">          1 :           .get();</span></a>
<a name="531"><span class="lineNum">     531 </span>            : </a>
<a name="532"><span class="lineNum">     532 </span>            :       // if there are any tags with the name tagName, return true</a>
<a name="533"><span class="lineNum">     533 </span><span class="lineCov">          2 :       if (query.docs.isNotEmpty) {</span></a>
<a name="534"><span class="lineNum">     534 </span><span class="lineCov">          1 :         List&lt;String&gt; pleaseWorkIDs = [];</span></a>
<a name="535"><span class="lineNum">     535 </span><span class="lineCov">          5 :         for (var id in query.docs[0].data()[&quot;includedIDs&quot;]) {</span></a>
<a name="536"><span class="lineNum">     536 </span><span class="lineCov">          2 :           pleaseWorkIDs.add(id.toString());</span></a>
<a name="537"><span class="lineNum">     537 </span>            :         }</a>
<a name="538"><span class="lineNum">     538 </span>            : </a>
<a name="539"><span class="lineNum">     539 </span><span class="lineCov">          1 :         Tag out = Tag(</span></a>
<a name="540"><span class="lineNum">     540 </span><span class="lineCov">          4 :           name: query.docs[0].data()[&quot;name&quot;],</span></a>
<a name="541"><span class="lineNum">     541 </span><span class="lineCov">          4 :           id: query.docs[0].data()[&quot;id&quot;],</span></a>
<a name="542"><span class="lineNum">     542 </span><span class="lineCov">          4 :           color: query.docs[0].data()[&quot;color&quot;],</span></a>
<a name="543"><span class="lineNum">     543 </span>            :           includedIDs: pleaseWorkIDs,</a>
<a name="544"><span class="lineNum">     544 </span>            :         );</a>
<a name="545"><span class="lineNum">     545 </span>            :         return out;</a>
<a name="546"><span class="lineNum">     546 </span>            :       } else {</a>
<a name="547"><span class="lineNum">     547 </span>            :         // otherwise, return false</a>
<a name="548"><span class="lineNum">     548 </span><span class="lineCov">          1 :         throw Exception(&quot;Tag not found&quot;);</span></a>
<a name="549"><span class="lineNum">     549 </span>            :       }</a>
<a name="550"><span class="lineNum">     550 </span>            :     } catch (e) {</a>
<a name="551"><span class="lineNum">     551 </span>            :       rethrow;</a>
<a name="552"><span class="lineNum">     552 </span>            :     }</a>
<a name="553"><span class="lineNum">     553 </span>            :   }</a>
<a name="554"><span class="lineNum">     554 </span>            : </a>
<a name="555"><span class="lineNum">     555 </span>            :   // Returns whether or not a tag with name tagName exists</a>
<a name="556"><span class="lineNum">     556 </span><span class="lineCov">          1 :   Future&lt;bool&gt; doesTagExist(String tagName) async {</span></a>
<a name="557"><span class="lineNum">     557 </span>            :     try {</a>
<a name="558"><span class="lineNum">     558 </span>            :       // get all tags with the name tagName</a>
<a name="559"><span class="lineNum">     559 </span><span class="lineCov">          1 :       var query = await users</span></a>
<a name="560"><span class="lineNum">     560 </span><span class="lineCov">          2 :           .doc(userid)</span></a>
<a name="561"><span class="lineNum">     561 </span><span class="lineCov">          1 :           .collection('tags')</span></a>
<a name="562"><span class="lineNum">     562 </span><span class="lineCov">          1 :           .where(&quot;name&quot;, isEqualTo: tagName)</span></a>
<a name="563"><span class="lineNum">     563 </span><span class="lineCov">          1 :           .get();</span></a>
<a name="564"><span class="lineNum">     564 </span>            : </a>
<a name="565"><span class="lineNum">     565 </span>            :       // if there are any tags with the name tagName, return true</a>
<a name="566"><span class="lineNum">     566 </span><span class="lineCov">          2 :       if (query.docs.isNotEmpty) {</span></a>
<a name="567"><span class="lineNum">     567 </span>            :         return true;</a>
<a name="568"><span class="lineNum">     568 </span>            :       } else {</a>
<a name="569"><span class="lineNum">     569 </span>            :         // otherwise, return false</a>
<a name="570"><span class="lineNum">     570 </span>            :         return false;</a>
<a name="571"><span class="lineNum">     571 </span>            :       }</a>
<a name="572"><span class="lineNum">     572 </span>            :     } catch (e) {</a>
<a name="573"><span class="lineNum">     573 </span>            :       rethrow;</a>
<a name="574"><span class="lineNum">     574 </span>            :     }</a>
<a name="575"><span class="lineNum">     575 </span>            :   }</a>
<a name="576"><span class="lineNum">     576 </span>            : </a>
<a name="577"><span class="lineNum">     577 </span>            :   /// Get ID of all Undertakings with the given tag</a>
<a name="578"><span class="lineNum">     578 </span>            :   /// Returns a list of IDs</a>
<a name="579"><span class="lineNum">     579 </span>            :   /// Returns empty list if tag doesn't exist</a>
<a name="580"><span class="lineNum">     580 </span><span class="lineCov">          1 :   Future&lt;List&lt;String&gt;&gt; getUndertakingsWithTag(String tagName) async {</span></a>
<a name="581"><span class="lineNum">     581 </span><span class="lineCov">          1 :     List&lt;String&gt; out = [];</span></a>
<a name="582"><span class="lineNum">     582 </span>            :     Tag tag;</a>
<a name="583"><span class="lineNum">     583 </span>            : </a>
<a name="584"><span class="lineNum">     584 </span>            :     try {</a>
<a name="585"><span class="lineNum">     585 </span>            :       // attempt to get tag</a>
<a name="586"><span class="lineNum">     586 </span><span class="lineCov">          1 :       tag = await getTagByName(tagName);</span></a>
<a name="587"><span class="lineNum">     587 </span>            :     } catch (e) {</a>
<a name="588"><span class="lineNum">     588 </span>            :       // if tag doesn't exist, return empty list</a>
<a name="589"><span class="lineNum">     589 </span>            :       return out;</a>
<a name="590"><span class="lineNum">     590 </span>            :     }</a>
<a name="591"><span class="lineNum">     591 </span>            : </a>
<a name="592"><span class="lineNum">     592 </span><span class="lineCov">          1 :     return tag.includedIDs;</span></a>
<a name="593"><span class="lineNum">     593 </span>            :   }</a>
<a name="594"><span class="lineNum">     594 </span>            : </a>
<a name="595"><span class="lineNum">     595 </span>            :   /// Get all tags in the database</a>
<a name="596"><span class="lineNum">     596 </span>            :   /// Returns a list of maps, where each map is a tag and its data:</a>
<a name="597"><span class="lineNum">     597 </span>            :   /// {&quot;name&quot;: &quot;tagName&quot;, &quot;id&quot;: &quot;tagID&quot;, &quot;color&quot;: &quot;tagColor&quot;, &quot;includedIDs&quot;: [&quot;taskID1&quot;, &quot;taskID2&quot;, ...]}</a>
<a name="598"><span class="lineNum">     598 </span>            :   /// (includedIDs is a list of task IDs)</a>
<a name="599"><span class="lineNum">     599 </span><span class="lineCov">          1 :   Future&lt;List&lt;Tag&gt;&gt; getAllTags() async {</span></a>
<a name="600"><span class="lineNum">     600 </span><span class="lineCov">          1 :     List&lt;Tag&gt; allTags = [];</span></a>
<a name="601"><span class="lineNum">     601 </span><span class="lineCov">          5 :     final tagDocs = await users.doc(userid).collection(&quot;tags&quot;).get();</span></a>
<a name="602"><span class="lineNum">     602 </span>            : </a>
<a name="603"><span class="lineNum">     603 </span><span class="lineCov">          2 :     for (var doc in tagDocs.docs) {</span></a>
<a name="604"><span class="lineNum">     604 </span><span class="lineCov">          3 :       allTags.add(Tag.fromMap(doc.data()));</span></a>
<a name="605"><span class="lineNum">     605 </span>            :     }</a>
<a name="606"><span class="lineNum">     606 </span>            : </a>
<a name="607"><span class="lineNum">     607 </span>            :     return allTags;</a>
<a name="608"><span class="lineNum">     608 </span>            :   }</a>
<a name="609"><span class="lineNum">     609 </span>            : </a>
<a name="610"><span class="lineNum">     610 </span>            :   /// Add an existing tag to an undertaking</a>
<a name="611"><span class="lineNum">     611 </span>            :   /// Adds the task ID to the tag, and adds the tag ID to the task</a>
<a name="612"><span class="lineNum">     612 </span><span class="lineCov">          1 :   Future&lt;void&gt; addTagToUndertaking(Undertaking ut, Tag tag) async {</span></a>
<a name="613"><span class="lineNum">     613 </span>            :     // add undertaking ID to task</a>
<a name="614"><span class="lineNum">     614 </span><span class="lineCov">          3 :     ut.tags.add(tag.id);</span></a>
<a name="615"><span class="lineNum">     615 </span>            :     // add undertaking ID to tag</a>
<a name="616"><span class="lineNum">     616 </span><span class="lineCov">          3 :     tag.includedIDs.add(ut.id);</span></a>
<a name="617"><span class="lineNum">     617 </span>            : </a>
<a name="618"><span class="lineNum">     618 </span>            :     // update undertaking</a>
<a name="619"><span class="lineNum">     619 </span><span class="lineCov">          1 :     if (ut is Task) {</span></a>
<a name="620"><span class="lineNum">     620 </span><span class="lineCov">          1 :       await setTask(ut);</span></a>
<a name="621"><span class="lineNum">     621 </span><span class="lineCov">          1 :     } else if (ut is Event) {</span></a>
<a name="622"><span class="lineNum">     622 </span><span class="lineCov">          1 :       await setEvent(ut);</span></a>
<a name="623"><span class="lineNum">     623 </span>            :     } else {</a>
<a name="624"><span class="lineNum">     624 </span><span class="lineNoCov">          0 :       throw Exception(&quot;Undertaking is neither a task nor an event! (somehow)&quot;);</span></a>
<a name="625"><span class="lineNum">     625 </span>            :     }</a>
<a name="626"><span class="lineNum">     626 </span>            : </a>
<a name="627"><span class="lineNum">     627 </span>            :     // update tag</a>
<a name="628"><span class="lineNum">     628 </span><span class="lineCov">          1 :     await setTag(tag);</span></a>
<a name="629"><span class="lineNum">     629 </span>            :   }</a>
<a name="630"><span class="lineNum">     630 </span>            : </a>
<a name="631"><span class="lineNum">     631 </span>            :   /// Just a wrapper for addTagToUndertaking()</a>
<a name="632"><span class="lineNum">     632 </span><span class="lineCov">          1 :   Future&lt;void&gt; addTagToTask(Task task, Tag tag) async {</span></a>
<a name="633"><span class="lineNum">     633 </span><span class="lineCov">          1 :     await addTagToUndertaking(task, tag);</span></a>
<a name="634"><span class="lineNum">     634 </span>            :   }</a>
<a name="635"><span class="lineNum">     635 </span>            : </a>
<a name="636"><span class="lineNum">     636 </span>            :   /// Just a wrapper for addTagToUndertaking()</a>
<a name="637"><span class="lineNum">     637 </span>            :   /// TODO: Add a check to make sure that the event is not recurring</a>
<a name="638"><span class="lineNum">     638 </span><span class="lineCov">          1 :   Future&lt;void&gt; addTagToEvent(Event event, Tag tag) async {</span></a>
<a name="639"><span class="lineNum">     639 </span><span class="lineCov">          1 :     await addTagToUndertaking(event, tag);</span></a>
<a name="640"><span class="lineNum">     640 </span>            :   }</a>
<a name="641"><span class="lineNum">     641 </span>            : </a>
<a name="642"><span class="lineNum">     642 </span>            :   /// Remove a tag from an undertaking</a>
<a name="643"><span class="lineNum">     643 </span>            :   /// Removes the task ID from the tag, and removes the tag ID from the task</a>
<a name="644"><span class="lineNum">     644 </span>            :   /// If the tag has no more tasks, delete the tag</a>
<a name="645"><span class="lineNum">     645 </span><span class="lineCov">          1 :   Future&lt;void&gt; removeTagFromUndertaking(Undertaking utaken, Tag tag) async {</span></a>
<a name="646"><span class="lineNum">     646 </span>            :     // remove undertaking ID from task</a>
<a name="647"><span class="lineNum">     647 </span><span class="lineCov">          3 :     utaken.tags.remove(tag.id);</span></a>
<a name="648"><span class="lineNum">     648 </span>            :     // remove undertaking ID from tag</a>
<a name="649"><span class="lineNum">     649 </span><span class="lineCov">          3 :     tag.includedIDs.remove(utaken.id);</span></a>
<a name="650"><span class="lineNum">     650 </span>            : </a>
<a name="651"><span class="lineNum">     651 </span>            :     // update task</a>
<a name="652"><span class="lineNum">     652 </span><span class="lineCov">          1 :     if (utaken is Task) {</span></a>
<a name="653"><span class="lineNum">     653 </span><span class="lineCov">          1 :       await setTask(utaken);</span></a>
<a name="654"><span class="lineNum">     654 </span><span class="lineCov">          1 :     } else if (utaken is Event) {</span></a>
<a name="655"><span class="lineNum">     655 </span><span class="lineCov">          1 :       await setEvent(utaken);</span></a>
<a name="656"><span class="lineNum">     656 </span>            :     } else {</a>
<a name="657"><span class="lineNum">     657 </span><span class="lineNoCov">          0 :       throw Exception(&quot;Undertaking is neither a task nor an event! (somehow)&quot;);</span></a>
<a name="658"><span class="lineNum">     658 </span>            :     }</a>
<a name="659"><span class="lineNum">     659 </span>            : </a>
<a name="660"><span class="lineNum">     660 </span>            :     // update tag</a>
<a name="661"><span class="lineNum">     661 </span><span class="lineCov">          1 :     await setTag(tag);</span></a>
<a name="662"><span class="lineNum">     662 </span>            : </a>
<a name="663"><span class="lineNum">     663 </span>            :     // delete tag if it has no more tasks</a>
<a name="664"><span class="lineNum">     664 </span><span class="lineCov">          2 :     if (tag.includedIDs.isEmpty) {</span></a>
<a name="665"><span class="lineNum">     665 </span><span class="lineCov">          1 :       await deleteTag(tag);</span></a>
<a name="666"><span class="lineNum">     666 </span>            :     }</a>
<a name="667"><span class="lineNum">     667 </span>            :   }</a>
<a name="668"><span class="lineNum">     668 </span>            : </a>
<a name="669"><span class="lineNum">     669 </span>            :   /// Just a wrapper for removeTagFromUndertaking()</a>
<a name="670"><span class="lineNum">     670 </span>            :   /// TODO: Add a check to make sure that the event is not recurring</a>
<a name="671"><span class="lineNum">     671 </span><span class="lineCov">          1 :   Future&lt;void&gt; removeTagFromEvent(Event event, Tag tag) async {</span></a>
<a name="672"><span class="lineNum">     672 </span><span class="lineCov">          1 :     await removeTagFromUndertaking(event, tag);</span></a>
<a name="673"><span class="lineNum">     673 </span>            :   }</a>
<a name="674"><span class="lineNum">     674 </span>            : </a>
<a name="675"><span class="lineNum">     675 </span>            :   /// Just a wrapper for removeTagFromUndertaking()</a>
<a name="676"><span class="lineNum">     676 </span><span class="lineCov">          1 :   Future&lt;void&gt; removeTagFromTask(Task task, Tag tag) async {</span></a>
<a name="677"><span class="lineNum">     677 </span><span class="lineCov">          1 :     await removeTagFromUndertaking(task, tag);</span></a>
<a name="678"><span class="lineNum">     678 </span>            :   }</a>
<a name="679"><span class="lineNum">     679 </span>            : </a>
<a name="680"><span class="lineNum">     680 </span>            :   /// Delete a tag from the database</a>
<a name="681"><span class="lineNum">     681 </span>            :   /// DOES NOT ALTER EXISTING TASKS, E.G.</a>
<a name="682"><span class="lineNum">     682 </span>            :   /// IF A TASK HAS A TAG THAT IS DELETED, THE TASK WILL STILL HAVE THE TAG</a>
<a name="683"><span class="lineNum">     683 </span>            :   /// USE removeTagFromUndertaking() TO REMOVE A TAG FROM A TASK</a>
<a name="684"><span class="lineNum">     684 </span>            :   /// Returns true if tag was deleted, false if tag doesn't exist</a>
<a name="685"><span class="lineNum">     685 </span><span class="lineCov">          1 :   Future&lt;bool&gt; deleteTag(Tag tag) async {</span></a>
<a name="686"><span class="lineNum">     686 </span>            :     // check if tag exists</a>
<a name="687"><span class="lineNum">     687 </span><span class="lineCov">          1 :     final tagDocs = await users</span></a>
<a name="688"><span class="lineNum">     688 </span><span class="lineCov">          2 :         .doc(userid)</span></a>
<a name="689"><span class="lineNum">     689 </span><span class="lineCov">          1 :         .collection(&quot;tags&quot;)</span></a>
<a name="690"><span class="lineNum">     690 </span><span class="lineCov">          2 :         .where(&quot;name&quot;, isEqualTo: tag.name)</span></a>
<a name="691"><span class="lineNum">     691 </span><span class="lineCov">          1 :         .get();</span></a>
<a name="692"><span class="lineNum">     692 </span>            : </a>
<a name="693"><span class="lineNum">     693 </span><span class="lineCov">          2 :     if (tagDocs.docs.isEmpty) {</span></a>
<a name="694"><span class="lineNum">     694 </span>            :       return false;</a>
<a name="695"><span class="lineNum">     695 </span>            :     }</a>
<a name="696"><span class="lineNum">     696 </span>            : </a>
<a name="697"><span class="lineNum">     697 </span>            :     // delete tag</a>
<a name="698"><span class="lineNum">     698 </span><span class="lineCov">          9 :     await users.doc(userid).collection(&quot;tags&quot;).doc(tagDocs.docs[0].id).delete();</span></a>
<a name="699"><span class="lineNum">     699 </span>            :     return true;</a>
<a name="700"><span class="lineNum">     700 </span>            :   }</a>
<a name="701"><span class="lineNum">     701 </span>            : </a>
<a name="702"><span class="lineNum">     702 </span>            :   ///////////////////////////////////////////////////////////////////////</a>
<a name="703"><span class="lineNum">     703 </span>            : </a>
<a name="704"><span class="lineNum">     704 </span>            :   /// Returns a 3-tuple of List&lt;Task&gt;</a>
<a name="705"><span class="lineNum">     705 </span>            :   /// Each list has tasks that are either active, completed, or delayed in a time window</a>
<a name="706"><span class="lineNum">     706 </span><span class="lineNoCov">          0 :   Future&lt;List&lt;Task&gt;&gt; getTasksDueDay(DateTime dateStart) async {</span></a>
<a name="707"><span class="lineNum">     707 </span><span class="lineNoCov">          0 :     dateStart = getDateOnly(dateStart);</span></a>
<a name="708"><span class="lineNum">     708 </span>            : </a>
<a name="709"><span class="lineNum">     709 </span>            :     Map&lt;DateTime, List&lt;Task&gt;&gt; tasksDueMap;</a>
<a name="710"><span class="lineNum">     710 </span>            :     tasksDueMap =</a>
<a name="711"><span class="lineNum">     711 </span><span class="lineNoCov">          0 :         await getTasksDue(dateStart, getDateOnly(dateStart, offsetDays: 1));</span></a>
<a name="712"><span class="lineNum">     712 </span>            : </a>
<a name="713"><span class="lineNum">     713 </span><span class="lineNoCov">          0 :     return tasksDueMap[dateStart] ?? [];</span></a>
<a name="714"><span class="lineNum">     714 </span>            :   }</a>
<a name="715"><span class="lineNum">     715 </span>            : </a>
<a name="716"><span class="lineNum">     716 </span>            :   /// Returns a 3-tuple of Maps&lt;DateTime, List&lt;Task&gt;&gt; where each map goes from 1 week from dateStart</a>
<a name="717"><span class="lineNum">     717 </span>            :   /// Each map has lists of tasks that are either active, completed, or delayed on a day</a>
<a name="718"><span class="lineNum">     718 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;DateTime, List&lt;Task&gt;&gt;&gt; getTasksDueWeek(DateTime dateStart) async {</span></a>
<a name="719"><span class="lineNum">     719 </span>            :     int daysToNextWeek = 7;</a>
<a name="720"><span class="lineNum">     720 </span><span class="lineNoCov">          0 :     DateTime oneWeekLater = getDateOnly(dateStart, offsetDays: daysToNextWeek);</span></a>
<a name="721"><span class="lineNum">     721 </span><span class="lineNoCov">          0 :     return await getTasksDue(dateStart, oneWeekLater);</span></a>
<a name="722"><span class="lineNum">     722 </span>            :   }</a>
<a name="723"><span class="lineNum">     723 </span>            : </a>
<a name="724"><span class="lineNum">     724 </span>            :   /// Returns a 3-tuple of Maps&lt;DateTime, List&lt;Task&gt;&gt; where each map goes from 1 month from dateStart</a>
<a name="725"><span class="lineNum">     725 </span>            :   /// Each map has lists of tasks that are either active, completed, or delayed on a day</a>
<a name="726"><span class="lineNum">     726 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;DateTime, List&lt;Task&gt;&gt;&gt; getTasksDueMonth(DateTime dateStart) async {</span></a>
<a name="727"><span class="lineNum">     727 </span>            :     DateTime nextMonth =</a>
<a name="728"><span class="lineNum">     728 </span><span class="lineNoCov">          0 :         DateTime(dateStart.year, dateStart.month + 1, dateStart.day);</span></a>
<a name="729"><span class="lineNum">     729 </span><span class="lineNoCov">          0 :     return getTasksDue(dateStart, nextMonth);</span></a>
<a name="730"><span class="lineNum">     730 </span>            :   }</a>
<a name="731"><span class="lineNum">     731 </span>            : </a>
<a name="732"><span class="lineNum">     732 </span>            :   // todo: figure out pagination support. from my findings, firestore has poor support for this when also doing queries, and this is only supported with third party services (there are libraries for 3rd parties though), which may not be free :(</a>
<a name="733"><span class="lineNum">     733 </span>            :   /// Perform a query on a user collection with a certain document key</a>
<a name="734"><span class="lineNum">     734 </span>            :   ///</a>
<a name="735"><span class="lineNum">     735 </span>            :   /// Takes a query string and value to limit number of outputs number, user collection key, and document key to search with</a>
<a name="736"><span class="lineNum">     736 </span>            :   /// Returns found elements that the query is a substring of, with the amount in, with amount specified by limit</a>
<a name="737"><span class="lineNum">     737 </span>            :   /// This substring search only works if the value of the document key is type string</a>
<a name="738"><span class="lineNum">     738 </span>            :   /// Note: this is not a true substring search, more of a prefix-substring search. See: https://github.com/Scrumbags115/plannertarium/pull/50#issuecomment-1823732365</a>
<a name="739"><span class="lineNum">     739 </span><span class="lineNoCov">          0 :   Future&lt;QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt;&gt; _substringQuery(</span></a>
<a name="740"><span class="lineNum">     740 </span>            :       String query, int limit, String collectionKey, String documentKey) async {</a>
<a name="741"><span class="lineNum">     741 </span>            :     // One downside is that this is apparently case sensitive, we probably can't do much about that unless we create new fields where all text is lowercase/consistent case</a>
<a name="742"><span class="lineNum">     742 </span>            :     // \uf8ff is used as that is just a large unicode value and tells firestore to use a high upper range</a>
<a name="743"><span class="lineNum">     743 </span><span class="lineNoCov">          0 :     return await users</span></a>
<a name="744"><span class="lineNum">     744 </span><span class="lineNoCov">          0 :         .doc(userid)</span></a>
<a name="745"><span class="lineNum">     745 </span><span class="lineNoCov">          0 :         .collection(collectionKey)</span></a>
<a name="746"><span class="lineNum">     746 </span><span class="lineNoCov">          0 :         .where(documentKey, isGreaterThanOrEqualTo: query)</span></a>
<a name="747"><span class="lineNum">     747 </span><span class="lineNoCov">          0 :         .where(documentKey, isLessThanOrEqualTo: '$query\uf8ff')</span></a>
<a name="748"><span class="lineNum">     748 </span><span class="lineNoCov">          0 :         .limit(limit)</span></a>
<a name="749"><span class="lineNum">     749 </span><span class="lineNoCov">          0 :         .get();</span></a>
<a name="750"><span class="lineNum">     750 </span>            :   }</a>
<a name="751"><span class="lineNum">     751 </span>            : </a>
<a name="752"><span class="lineNum">     752 </span>            :   /// Turns a QuerySnapshot of tasks into a map of tasks</a>
<a name="753"><span class="lineNum">     753 </span><span class="lineNoCov">          0 :   Map&lt;String, Task&gt; _collectTasks(</span></a>
<a name="754"><span class="lineNum">     754 </span>            :       QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; querySnapshot) {</a>
<a name="755"><span class="lineNum">     755 </span><span class="lineNoCov">          0 :     Map&lt;String, Task&gt; taskMap = {};</span></a>
<a name="756"><span class="lineNum">     756 </span><span class="lineNoCov">          0 :     for (final doc in querySnapshot.docs) {</span></a>
<a name="757"><span class="lineNum">     757 </span><span class="lineNoCov">          0 :       taskMap[doc.id] = Task.fromMap(doc.data(), id: doc.id);</span></a>
<a name="758"><span class="lineNum">     758 </span>            :     }</a>
<a name="759"><span class="lineNum">     759 </span>            :     return taskMap;</a>
<a name="760"><span class="lineNum">     760 </span>            :   }</a>
<a name="761"><span class="lineNum">     761 </span>            : </a>
<a name="762"><span class="lineNum">     762 </span>            :   /// Turns a QuerySnapshot of tasks into a map of tasks</a>
<a name="763"><span class="lineNum">     763 </span><span class="lineNoCov">          0 :   Map&lt;String, Event&gt; _collectEvents(</span></a>
<a name="764"><span class="lineNum">     764 </span>            :       QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; querySnapshot) {</a>
<a name="765"><span class="lineNum">     765 </span><span class="lineNoCov">          0 :     Map&lt;String, Event&gt; taskMap = {};</span></a>
<a name="766"><span class="lineNum">     766 </span><span class="lineNoCov">          0 :     for (final doc in querySnapshot.docs) {</span></a>
<a name="767"><span class="lineNum">     767 </span><span class="lineNoCov">          0 :       taskMap[doc.id] = Event.fromMap(doc.data(), id: doc.id);</span></a>
<a name="768"><span class="lineNum">     768 </span>            :     }</a>
<a name="769"><span class="lineNum">     769 </span>            :     return taskMap;</a>
<a name="770"><span class="lineNum">     770 </span>            :   }</a>
<a name="771"><span class="lineNum">     771 </span>            : </a>
<a name="772"><span class="lineNum">     772 </span>            :   /// Search function to query a task name</a>
<a name="773"><span class="lineNum">     773 </span>            :   ///</a>
<a name="774"><span class="lineNum">     774 </span>            :   /// Takes a query string and value to limit number of outputs</a>
<a name="775"><span class="lineNum">     775 </span>            :   /// Returns tasks that the query is a substring in, with amount specified by limit</a>
<a name="776"><span class="lineNum">     776 </span>            :   /// Return format is map of tasks</a>
<a name="777"><span class="lineNum">     777 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;String, Task&gt;&gt; searchTaskNames(String query, int limit) async {</span></a>
<a name="778"><span class="lineNum">     778 </span>            :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; queriedTaskResults =</a>
<a name="779"><span class="lineNum">     779 </span><span class="lineNoCov">          0 :         await _substringQuery(query, limit, &quot;tasks&quot;, &quot;name&quot;);</span></a>
<a name="780"><span class="lineNum">     780 </span>            :     // collect outputs</a>
<a name="781"><span class="lineNum">     781 </span><span class="lineNoCov">          0 :     return _collectTasks(queriedTaskResults);</span></a>
<a name="782"><span class="lineNum">     782 </span>            :   }</a>
<a name="783"><span class="lineNum">     783 </span>            : </a>
<a name="784"><span class="lineNum">     784 </span>            :   /// Search function to query a event name</a>
<a name="785"><span class="lineNum">     785 </span>            :   ///</a>
<a name="786"><span class="lineNum">     786 </span>            :   /// Takes a query string and value to limit number of outputs</a>
<a name="787"><span class="lineNum">     787 </span>            :   /// Returns events that the query is a substring in, with amount specified by limit</a>
<a name="788"><span class="lineNum">     788 </span>            :   /// Return format is map of events</a>
<a name="789"><span class="lineNum">     789 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;String, Event&gt;&gt; searchEventNames(String query, int limit) async {</span></a>
<a name="790"><span class="lineNum">     790 </span>            :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; queriedEventResults =</a>
<a name="791"><span class="lineNum">     791 </span><span class="lineNoCov">          0 :         await _substringQuery(query, limit, &quot;events&quot;, &quot;name&quot;);</span></a>
<a name="792"><span class="lineNum">     792 </span>            :     // collect outputs</a>
<a name="793"><span class="lineNum">     793 </span><span class="lineNoCov">          0 :     return _collectEvents(queriedEventResults);</span></a>
<a name="794"><span class="lineNum">     794 </span>            :   }</a>
<a name="795"><span class="lineNum">     795 </span>            : </a>
<a name="796"><span class="lineNum">     796 </span>            :   /// Search function to query a task description</a>
<a name="797"><span class="lineNum">     797 </span>            :   ///</a>
<a name="798"><span class="lineNum">     798 </span>            :   /// Takes a query string and value to limit number of outputs</a>
<a name="799"><span class="lineNum">     799 </span>            :   /// Returns tasks that the query is a substring in, with amount specified by limit</a>
<a name="800"><span class="lineNum">     800 </span>            :   /// Return format is map of tasks</a>
<a name="801"><span class="lineNum">     801 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;String, Task&gt;&gt; searchTaskDescription(</span></a>
<a name="802"><span class="lineNum">     802 </span>            :       String query, int limit) async {</a>
<a name="803"><span class="lineNum">     803 </span>            :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; queriedTaskResults =</a>
<a name="804"><span class="lineNum">     804 </span><span class="lineNoCov">          0 :         await _substringQuery(query, limit, &quot;tasks&quot;, &quot;description&quot;);</span></a>
<a name="805"><span class="lineNum">     805 </span>            :     // collect outputs</a>
<a name="806"><span class="lineNum">     806 </span><span class="lineNoCov">          0 :     return _collectTasks(queriedTaskResults);</span></a>
<a name="807"><span class="lineNum">     807 </span>            :   }</a>
<a name="808"><span class="lineNum">     808 </span>            : </a>
<a name="809"><span class="lineNum">     809 </span>            :   /// Search function to query a event description</a>
<a name="810"><span class="lineNum">     810 </span>            :   ///</a>
<a name="811"><span class="lineNum">     811 </span>            :   /// Takes a query string and value to limit number of outputs</a>
<a name="812"><span class="lineNum">     812 </span>            :   /// Returns events that the query is a substring in, with amount specified by limit</a>
<a name="813"><span class="lineNum">     813 </span>            :   /// Return format is map of events</a>
<a name="814"><span class="lineNum">     814 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;String, Event&gt;&gt; searchEventDescription(</span></a>
<a name="815"><span class="lineNum">     815 </span>            :       String query, int limit) async {</a>
<a name="816"><span class="lineNum">     816 </span>            :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; queriedEventResults =</a>
<a name="817"><span class="lineNum">     817 </span><span class="lineNoCov">          0 :         await _substringQuery(query, limit, &quot;events&quot;, &quot;description&quot;);</span></a>
<a name="818"><span class="lineNum">     818 </span>            :     // collect outputs</a>
<a name="819"><span class="lineNum">     819 </span><span class="lineNoCov">          0 :     return _collectEvents(queriedEventResults);</span></a>
<a name="820"><span class="lineNum">     820 </span>            :   }</a>
<a name="821"><span class="lineNum">     821 </span>            : </a>
<a name="822"><span class="lineNum">     822 </span>            :   /// Search function to query a task location</a>
<a name="823"><span class="lineNum">     823 </span>            :   ///</a>
<a name="824"><span class="lineNum">     824 </span>            :   /// Takes a query string and value to limit number of outputs</a>
<a name="825"><span class="lineNum">     825 </span>            :   /// Returns tasks that the query is a substring in, with amount specified by limit</a>
<a name="826"><span class="lineNum">     826 </span>            :   /// Return format is map of tasks</a>
<a name="827"><span class="lineNum">     827 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;String, Task&gt;&gt; searchTaskLocation(String query, int limit) async {</span></a>
<a name="828"><span class="lineNum">     828 </span>            :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; queriedTaskResults =</a>
<a name="829"><span class="lineNum">     829 </span><span class="lineNoCov">          0 :         await _substringQuery(query, limit, &quot;tasks&quot;, &quot;location&quot;);</span></a>
<a name="830"><span class="lineNum">     830 </span>            :     // collect outputs</a>
<a name="831"><span class="lineNum">     831 </span><span class="lineNoCov">          0 :     return _collectTasks(queriedTaskResults);</span></a>
<a name="832"><span class="lineNum">     832 </span>            :   }</a>
<a name="833"><span class="lineNum">     833 </span>            : </a>
<a name="834"><span class="lineNum">     834 </span>            :   /// Search function to query a event location</a>
<a name="835"><span class="lineNum">     835 </span>            :   ///</a>
<a name="836"><span class="lineNum">     836 </span>            :   /// Takes a query string and value to limit number of outputs</a>
<a name="837"><span class="lineNum">     837 </span>            :   /// Returns events that the query is a substring in, with amount specified by limit</a>
<a name="838"><span class="lineNum">     838 </span>            :   /// Return format is map of events</a>
<a name="839"><span class="lineNum">     839 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;String, Event&gt;&gt; searchEventLocation(</span></a>
<a name="840"><span class="lineNum">     840 </span>            :       String query, int limit) async {</a>
<a name="841"><span class="lineNum">     841 </span>            :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; queriedEventResults =</a>
<a name="842"><span class="lineNum">     842 </span><span class="lineNoCov">          0 :         await _substringQuery(query, limit, &quot;events&quot;, &quot;location&quot;);</span></a>
<a name="843"><span class="lineNum">     843 </span>            :     // collect outputs</a>
<a name="844"><span class="lineNum">     844 </span><span class="lineNoCov">          0 :     return _collectEvents(queriedEventResults);</span></a>
<a name="845"><span class="lineNum">     845 </span>            :   }</a>
<a name="846"><span class="lineNum">     846 </span>            : </a>
<a name="847"><span class="lineNum">     847 </span>            :   /// Query for tags with array-contains</a>
<a name="848"><span class="lineNum">     848 </span>            :   ///</a>
<a name="849"><span class="lineNum">     849 </span>            :   /// takes a query, limit, collection key</a>
<a name="850"><span class="lineNum">     850 </span><span class="lineNoCov">          0 :   Future&lt;QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt;&gt; _tagQuery(</span></a>
<a name="851"><span class="lineNum">     851 </span>            :       String query, int limit, String collectionKey) async {</a>
<a name="852"><span class="lineNum">     852 </span><span class="lineNoCov">          0 :     return await users</span></a>
<a name="853"><span class="lineNum">     853 </span><span class="lineNoCov">          0 :         .doc(userid)</span></a>
<a name="854"><span class="lineNum">     854 </span><span class="lineNoCov">          0 :         .collection(collectionKey)</span></a>
<a name="855"><span class="lineNum">     855 </span><span class="lineNoCov">          0 :         .where('tags', arrayContains: query)</span></a>
<a name="856"><span class="lineNum">     856 </span><span class="lineNoCov">          0 :         .limit(limit)</span></a>
<a name="857"><span class="lineNum">     857 </span><span class="lineNoCov">          0 :         .get();</span></a>
<a name="858"><span class="lineNum">     858 </span>            :   }</a>
<a name="859"><span class="lineNum">     859 </span>            : </a>
<a name="860"><span class="lineNum">     860 </span>            :   /// Search function to query task tags</a>
<a name="861"><span class="lineNum">     861 </span>            :   ///</a>
<a name="862"><span class="lineNum">     862 </span>            :   /// Takes a query string and value to limit number of outputs</a>
<a name="863"><span class="lineNum">     863 </span>            :   /// Returns tasks that the query is in the tags of (not substring), with amount specified by limit</a>
<a name="864"><span class="lineNum">     864 </span>            :   /// Return format is map of tasks</a>
<a name="865"><span class="lineNum">     865 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;String, Task&gt;&gt; searchTaskTags(String query, int limit) async {</span></a>
<a name="866"><span class="lineNum">     866 </span>            :     // tags are a little weird since they are stored as a list, and firestore doesn't support substring searching for complex types</a>
<a name="867"><span class="lineNum">     867 </span>            :     // seems like the best they have available without 3rd party solutions is array-contains</a>
<a name="868"><span class="lineNum">     868 </span>            :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; queriedTaskResults =</a>
<a name="869"><span class="lineNum">     869 </span><span class="lineNoCov">          0 :         await _tagQuery(query, limit, &quot;tasks&quot;);</span></a>
<a name="870"><span class="lineNum">     870 </span>            :     // collect outputs</a>
<a name="871"><span class="lineNum">     871 </span><span class="lineNoCov">          0 :     return _collectTasks(queriedTaskResults);</span></a>
<a name="872"><span class="lineNum">     872 </span>            :   }</a>
<a name="873"><span class="lineNum">     873 </span>            : </a>
<a name="874"><span class="lineNum">     874 </span>            :   /// Search function to query event tags</a>
<a name="875"><span class="lineNum">     875 </span>            :   ///</a>
<a name="876"><span class="lineNum">     876 </span>            :   /// Takes a query string and value to limit number of outputs</a>
<a name="877"><span class="lineNum">     877 </span>            :   /// Returns events that the query is in the tags of (not substring), with amount specified by limit</a>
<a name="878"><span class="lineNum">     878 </span>            :   /// Return format is map of events</a>
<a name="879"><span class="lineNum">     879 </span><span class="lineNoCov">          0 :   Future&lt;Map&lt;String, Event&gt;&gt; searchEventTags(String query, int limit) async {</span></a>
<a name="880"><span class="lineNum">     880 </span>            :     final QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt; queriedEventResults =</a>
<a name="881"><span class="lineNum">     881 </span><span class="lineNoCov">          0 :         await _tagQuery(query, limit, &quot;events&quot;);</span></a>
<a name="882"><span class="lineNum">     882 </span>            :     // collect outputs</a>
<a name="883"><span class="lineNum">     883 </span><span class="lineNoCov">          0 :     return _collectEvents(queriedEventResults);</span></a>
<a name="884"><span class="lineNum">     884 </span>            :   }</a>
<a name="885"><span class="lineNum">     885 </span>            : }</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.15.alpha0w</a></td></tr>
  </table>
  <br>

</body>
</html>
